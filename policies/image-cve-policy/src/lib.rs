mod sbombastic;
use sbombastic::storage::v1alpha1::{vulnerability::Vulnerability, VulnerabilityReport};

mod settings;
use settings::{Settings, SeverityCount};

mod errors;
use errors::{CVEViolationStats, ImageValidationError, Violation};

use std::collections::{HashMap, HashSet};

use guest::prelude::*;
use kubewarden_policy_sdk::{
    host_capabilities::kubernetes::ListResourcesByNamespaceRequest, wapc_guest as guest,
};

use k8s_openapi::{
    api::{
        apps::v1::{DaemonSet, Deployment, ReplicaSet, StatefulSet},
        batch::v1::{CronJob, Job},
        core::v1::{Pod, PodSpec, ReplicationController},
    },
    apimachinery::pkg::apis::meta::v1::ObjectMeta,
    Metadata, Resource,
};
use kubewarden_policy_sdk::{
    accept_request, logging, protocol_version_guest, reject_request, request::ValidationRequest,
    validate_settings,
};
use lazy_static::lazy_static;
use serde::de::DeserializeOwned;
use slog::{debug, info, o, warn, Logger};

#[cfg(test)]
use crate::tests::{
    mock_kubernetes_sdk::list_resources_by_namespace, mock_oci_sdk::get_manifest_digest,
};

#[cfg(not(test))]
use kubewarden_policy_sdk::host_capabilities::{
    kubernetes::list_resources_by_namespace, oci::get_manifest_digest,
};

type ImageValidationErrors = HashMap<String, ImageValidationError>;

lazy_static! {
    static ref LOG_DRAIN: Logger =
        Logger::root(logging::KubewardenDrain::new(), o!("policy" => "image-cve"));
}

#[no_mangle]
pub extern "C" fn wapc_init() {
    register_function("validate", validate);
    register_function("validate_settings", validate_settings::<Settings>);
    register_function("protocol_version", protocol_version_guest);
}

fn validate(payload: &[u8]) -> CallResult {
    let validation_request: ValidationRequest<Settings> = ValidationRequest::new(payload)?;

    match validation_request.request.kind.kind.as_str() {
        "Deployment" => validate_resource::<Deployment>(validation_request, |deployment| {
            deployment.spec.as_ref()?.template.spec.clone()
        }),
        "ReplicaSet" => validate_resource::<ReplicaSet>(validation_request, |replicaset| {
            replicaset.spec.as_ref()?.template.as_ref()?.spec.clone()
        }),
        "StatefulSet" => validate_resource::<StatefulSet>(validation_request, |statefulset| {
            statefulset.spec.as_ref()?.template.spec.clone()
        }),
        "DaemonSet" => validate_resource::<DaemonSet>(validation_request, |daemonset| {
            daemonset.spec.as_ref()?.template.spec.clone()
        }),
        "ReplicationController" => {
            validate_resource::<ReplicationController>(validation_request, |rc| {
                rc.spec.as_ref()?.template.as_ref()?.spec.clone()
            })
        }
        "Job" => validate_resource::<Job>(validation_request, |job| {
            job.spec.as_ref()?.template.spec.clone()
        }),
        "CronJob" => validate_resource::<CronJob>(validation_request, |cronjob| {
            cronjob
                .spec
                .as_ref()?
                .job_template
                .spec
                .as_ref()?
                .template
                .spec
                .clone()
        }),
        "Pod" => validate_resource::<Pod>(validation_request, |pod| pod.spec.clone()),
        _ => {
            warn!(LOG_DRAIN, "cannot unmarshal resource: this policy does not know how to evaluate this resource; accept it");
            accept_request()
        }
    }
}

// validate any resource that contains a Pod. e.g. Deployment, StatefulSet, ...
// it does not modify the container with the manifest digest.
fn validate_resource<T>(
    validation_request: ValidationRequest<Settings>,
    extract_spec: fn(&T) -> Option<PodSpec>,
) -> CallResult
where
    T: Resource + Metadata<Ty = ObjectMeta> + DeserializeOwned,
{
    let resource = match serde_json::from_value::<T>(validation_request.request.object.clone()) {
        Ok(resource) => resource,
        Err(_) => {
            warn!(LOG_DRAIN, "cannot unmarshal resource: this policy does not know how to evaluate this resource; accept it");
            return accept_request();
        }
    };

    let spec = match extract_spec(&resource) {
        Some(spec) => spec,
        None => {
            return accept_request();
        }
    };

    let mut image_validation_errors = ImageValidationErrors::new();

    verify_all_images_in_podspec(
        &spec,
        &validation_request.settings,
        &mut image_validation_errors,
    );

    if image_validation_errors.is_empty() {
        return accept_request();
    }

    let rejection_details = image_validation_errors
        .iter()
        .map(|(image, error)| format!("{image}: {error}"))
        .collect::<Vec<String>>()
        .join(", ");

    reject_request(
        Some(format!(
            "Resource {} is not accepted: {}",
            resource.metadata().name.as_ref().unwrap(),
            rejection_details,
        )),
        None,
        None,
        None,
    )
}
/// verify all images defined in the PodSpec. The violations are stored in the `image_validation_errors` map.
fn verify_all_images_in_podspec(
    spec: &PodSpec,
    settings: &Settings,
    image_validation_errors: &mut ImageValidationErrors,
) {
    let mut images: Vec<String> = spec
        .containers
        .iter()
        .map(|c| c.image.clone().unwrap())
        .collect();

    if let Some(init_containers) = &spec.init_containers {
        let init_images: Vec<String> = init_containers
            .iter()
            .map(|c| c.image.clone().unwrap())
            .collect();
        images.extend(init_images);
    }

    if let Some(ephemeral_containers) = &spec.ephemeral_containers {
        let ephemeral_images: Vec<String> = ephemeral_containers
            .iter()
            .map(|c| c.image.clone().unwrap())
            .collect();

        images.extend(ephemeral_images);
    }

    for image in images {
        verify_container_image(&image, settings, image_validation_errors);
    }
}

/// verify the given image. The violations are stored in the `image_validation_errors` map.
fn verify_container_image(
    image: &str,
    settings: &Settings,
    image_validation_errors: &mut ImageValidationErrors,
) {
    if image_validation_errors.contains_key(image) {
        return;
    }

    let digest = match get_image_digest(image) {
        Ok(digest) => digest,
        Err(e) => {
            if settings.ignore_missing_vulnerability_report {
                info!(LOG_DRAIN,
                        "ignoring error while attempting to fetch the image manifest because ignoreMissingVulnerabilityReport is enabled";
                        "image" => image,
                        "error" => ?e,
                );

                return;
            }
            image_validation_errors.insert(image.to_string(), e);
            return;
        }
    };

    if let Err(e) = verify_image_vulnerabilities(&digest, settings) {
        image_validation_errors.insert(image.to_string(), e);
    }
}

/// obtains the manifest of the image. This can be done either by extracting the digest from the image reference or by fetching the manifest from the registry.
fn get_image_digest(image: &str) -> Result<String, ImageValidationError> {
    // The image reference might already contain its digest,
    // in that case we can return it directly, saving a network call
    let image_ref: oci_spec::distribution::Reference =
        image
            .parse()
            .map_err(|e: oci_spec::distribution::ParseError| {
                ImageValidationError::MalformedImageName(e.to_string())
            })?;
    if let Some(digest) = image_ref.digest() {
        return Ok(digest.to_string());
    }

    let digest = get_manifest_digest(image)
        .map_err(|e| ImageValidationError::ManifestFetchError(e.to_string()))?;

    Ok(digest.digest)
}

/// given the digest of an image, it verifies the vulnerabilities of the image.
fn verify_image_vulnerabilities(
    digest: &str,
    settings: &Settings,
) -> Result<(), ImageValidationError> {
    let namespace = settings.vulnerability_report_namespace.as_str();

    let vulnerability_reports = match list_resources_by_namespace(
        &ListResourcesByNamespaceRequest {
            api_version: "storage.sbombastic.rancher.io/v1alpha1".to_string(),
            kind: "VulnerabilityReport".to_string(),
            namespace: namespace.to_string(),
            label_selector: None,
            field_selector: Some(format!("imageMetadata.digest={digest}")),
        },
    ) {
        Ok(report) => report,
        Err(e) => {
            if settings.ignore_missing_vulnerability_report {
                info!(LOG_DRAIN,
                        "ignoring error while attempting to fetch the vulnerability report because ignoreMissingVulnerabilityReport is enabled";
                        "error" => ?e,
                        "digest" => digest,
                        "namespace" => namespace,
                );

                return Ok(());
            }

            warn!(LOG_DRAIN, "error fetching vulnerability report";
                           "error" => ?e,
                           "digest" => digest,
                           "namespace" => namespace,
            );

            return Err(ImageValidationError::VulnerabilityReportNotFound());
        }
    };

    if vulnerability_reports.items.is_empty() {
        if settings.ignore_missing_vulnerability_report {
            info!(LOG_DRAIN,
                    "ignoring missing vulnerability report because ignoreMissingVulnerabilityReport is enabled";
                    "digest" => digest,
                    "namespace" => namespace,
            );

            return Ok(());
        }

        return Err(ImageValidationError::VulnerabilityReportNotFound());
    }

    let vulnerability_report: &VulnerabilityReport = vulnerability_reports.items.first().unwrap();
    verify_vulnerability_report(&vulnerability_report.report, settings)?;

    Ok(())
}

fn verify_vulnerability_report(
    report: &sbombastic::storage::v1alpha1::Report,
    settings: &Settings,
) -> Result<(), ImageValidationError> {
    let always_denied_cves: Vec<String> = report
        .vulnerabilties_ids()
        .intersection(&settings.deny_always)
        .cloned()
        .collect();
    if !always_denied_cves.is_empty() {
        return Err(ImageValidationError::AffectedByDeniedCVE(
            always_denied_cves,
        ));
    }

    if !settings
        .max_severity
        .as_ref()
        .map_or_else(|| false, |ms| ms.is_configured())
    {
        return Ok(());
    }

    let max_severity = settings.max_severity.as_ref().unwrap();

    let violation_stats = CVEViolationStats {
        critical: find_violation(
            max_severity.critical.as_ref(),
            &report.critical_severity_vulnerabilitiest_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.critical_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
        high: find_violation(
            max_severity.high.as_ref(),
            &report.high_severity_vulnerabilities_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.high_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
        medium: find_violation(
            max_severity.medium.as_ref(),
            &report.medium_severity_vulnerabilities_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.medium_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
        low: find_violation(
            max_severity.low.as_ref(),
            &report.low_severity_vulnerabilities_with_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
            &report.low_severity_vulnerabilities_without_fixes(
                &settings.allow_always,
                settings.ignore_vex_status,
            ),
        ),
    };

    if violation_stats.has_violations() {
        return Err(ImageValidationError::MaxSeverityExceeded(Box::new(
            violation_stats,
        )));
    }

    Ok(())
}

fn find_violation(
    severity_count: Option<&SeverityCount>,
    vulnerabilities_with_fixes: &[&Vulnerability],
    vulnerabilities_without_fixes: &[&Vulnerability],
) -> Option<Violation> {
    debug!(LOG_DRAIN, "checking severity";
           "severity_count" => ?severity_count,
           "vulnerabilities_with_fixes" => vulnerabilities_with_fixes.len(),
           "vulnerabilities_without_fixes" => vulnerabilities_without_fixes.len(),
    );
    match severity_count {
        Some(settings::SeverityCount::Total(max)) => {
            let total = vulnerabilities_with_fixes.len() as u32
                + vulnerabilities_without_fixes.len() as u32;
            if total > *max {
                let ids_with_fix: HashSet<String> = vulnerabilities_with_fixes
                    .iter()
                    .map(|v| v.cve.to_owned())
                    .collect();
                let ids_without_fix: HashSet<String> = vulnerabilities_without_fixes
                    .iter()
                    .map(|v| v.cve.to_owned())
                    .collect();

                Some(errors::Violation {
                    allowed: settings::SeverityCount::Total(*max),
                    actual: total,
                    vulnerabilities: ids_without_fix.union(&ids_with_fix).cloned().collect(),
                })
            } else {
                None
            }
        }
        Some(settings::SeverityCount::TotalWithoutFixes(max)) => {
            if vulnerabilities_without_fixes.len() as u32 > *max {
                let ids: Vec<String> = vulnerabilities_without_fixes
                    .iter()
                    .map(|v| v.cve.to_owned())
                    .collect();

                Some(errors::Violation {
                    allowed: settings::SeverityCount::TotalWithoutFixes(*max),
                    actual: vulnerabilities_without_fixes.len() as u32,
                    vulnerabilities: ids,
                })
            } else {
                None
            }
        }
        None => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use anyhow::anyhow;
    use kubewarden_policy_sdk::{
        host_capabilities::oci::ManifestDigestResponse,
        request::{GroupVersionKind, KubernetesAdmissionRequest},
        response::ValidationResponse,
    };
    use mockall::automock;
    use rstest::rstest;
    use serde_json::json;
    use serial_test::serial;

    #[automock()]
    pub mod kubernetes_sdk {
        use kubewarden_policy_sdk::host_capabilities::kubernetes::ListResourcesByNamespaceRequest;

        #[allow(dead_code)]
        pub fn list_resources_by_namespace<T>(
            _req: &ListResourcesByNamespaceRequest,
        ) -> anyhow::Result<k8s_openapi::List<T>>
        where
            T: k8s_openapi::ListableResource + serde::de::DeserializeOwned + Clone + 'static,
        {
            Err(anyhow::anyhow!("not mocked"))
        }
    }

    #[automock()]
    pub mod oci_sdk {
        use kubewarden_policy_sdk::host_capabilities::oci::ManifestDigestResponse;

        #[allow(dead_code)]
        pub fn get_manifest_digest(_image: &str) -> anyhow::Result<ManifestDigestResponse> {
            Err(anyhow::anyhow!("not mocked"))
        }
    }

    fn pod(image: &str) -> serde_json::Value {
        json!(
        {
          "apiVersion": "v1",
          "kind": "Pod",
          "metadata": {
            "name": "nginx"
          },
          "spec": {
            "containers": [
              {
                "image": image,
                "name": "test-verify-image-signatures"
              }
            ]
          }
        })
    }

    #[rstest]
    #[case::always_denied_vulnerability_not_found(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always: HashSet::new(),
            deny_always: vec!["CVE-2021-1234".to_string()].into_iter().collect(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        true
    )]
    #[case::always_denied_vulnerability_found(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: None,
            allow_always: HashSet::new(),
            deny_always: vec!["CVE-2021-36159".to_string()].into_iter().collect(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        false
    )]
    #[case::no_critical_vulnerability_found(
        Some("vulnerabilityreport_no_critical.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: Some(SeverityCount::Total(0)),
                high: None,
                medium: None,
                low: None,
                unknown: None,
            }),
            allow_always: HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        true
    )]
    #[case::too_many_low_vulnerabilities(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: None,
                low: Some(SeverityCount::Total(1)),
                unknown: None,
            }),
            allow_always: HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        false
    )]
    #[case::too_many_medium_vulnerabilities(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: Some(SeverityCount::Total(4)),
                low: None,
                unknown: None,
            }),
            allow_always: HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        false
    )]
    #[case::always_allowed_cve_found(
        Some("vulnerabilityreport.yaml".to_owned()),
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: None,
                low: Some(SeverityCount::Total(0)),
                unknown: None,
            }),
            // this is the only LOW vulnerability
            allow_always: vec![
                "CVE-2021-23839".to_string()
            ].into_iter().collect(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        true
    )]
    #[case::vulnerability_report_not_found(
        None,
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: Some(SeverityCount::Total(0)),
                low: None,
                unknown: None,
            }),
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: false,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        false
    )]
    #[case::vulnerability_report_not_found_ignore_missing(
        None,
        Settings {
            max_severity: Some(settings::MaxSeverity {
                critical: None,
                high: None,
                medium: Some(SeverityCount::Total(0)),
                low: None,
                unknown: None,
            }),
            allow_always:  HashSet::new(),
            deny_always: HashSet::new(),
            ignore_missing_vulnerability_report: true,
            vulnerability_report_namespace: "sbombastic".to_string(),
            ignore_vex_status: false,
        },
        true
    )]
    #[serial]
    fn validate_pod(
        #[case] vulnerability_report_fixture: Option<String>,
        #[case] settings: Settings,
        #[case] accepted: bool,
    ) {
        use std::path::PathBuf;

        let image = "nginx:1.27.1";
        let image_digest = "sha256:1234";
        let resource = pod(image);

        let request = ValidationRequest {
            request: KubernetesAdmissionRequest {
                kind: GroupVersionKind {
                    kind: resource["kind"].as_str().unwrap().to_string(),
                    ..Default::default()
                },
                object: resource,
                ..Default::default()
            },
            settings,
        };

        let ctx_get_manifest_digest = mock_oci_sdk::get_manifest_digest_context();
        ctx_get_manifest_digest
            .expect()
            .times(1)
            .returning(move |img| {
                if img != image {
                    Err(anyhow!("it's not searching the expected image"))
                } else {
                    Ok(ManifestDigestResponse {
                        digest: image_digest.to_string(),
                    })
                }
            });

        let ctx_get_resource = mock_kubernetes_sdk::list_resources_by_namespace_context();
        ctx_get_resource
            .expect::<sbombastic::storage::v1alpha1::VulnerabilityReport>()
            .times(1)
            .returning(move |req| {
                if req.api_version != "storage.sbombastic.rancher.io/v1alpha1" {
                    return Err(anyhow!("it's not searching the expected API version"));
                }
                if req.kind != "VulnerabilityReport" {
                    return Err(anyhow!("it's not searching the expected Kind"));
                }
                if req.namespace != "sbombastic" {
                    return Err(anyhow!("it's not searching the expected namespace"));
                }
                if req.field_selector
                    != Some(format!("imageMetadata.digest={}", image_digest).to_owned())
                {
                    return Err(anyhow!(
                        "it's not searching the expected VulnerabilityReport"
                    ));
                }

                if let Some(fixture) = vulnerability_report_fixture.clone() {
                    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                        .join("test_data")
                        .join(fixture);
                    let fixture_file = std::fs::File::open(&fixture_path).map_err(|e| {
                        anyhow!("cannot open fixture file '{:?}': {}", fixture_path, e)
                    })?;
                    let vulnerability_report: VulnerabilityReport =
                        serde_yaml::from_reader(fixture_file).expect("cannot parse fixture file");

                    return Ok(k8s_openapi::List {
                        items: vec![vulnerability_report],
                        ..Default::default()
                    });
                };

                Ok(k8s_openapi::List {
                    items: vec![],
                    ..Default::default()
                })
            });

        let response = validate(serde_json::to_vec(&request).unwrap().as_slice()).unwrap();
        let response: ValidationResponse = serde_json::from_slice(&response).unwrap();
        assert_eq!(accepted, response.accepted, "response: {:?}", response);
    }
}
