use std::collections::HashSet;

use crate::sbombastic::storage::v1alpha1::image_metadata::ImageMetadata;
use crate::sbombastic::storage::v1alpha1::scan_result::ScanResult;
use crate::sbombastic::storage::v1alpha1::vulnerability::Vulnerability;

/// Report contains metadata about the scanned image and a list of vulnerability
/// results.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Report {
    /// Results per target (e.g., layer, package type)
    pub results: Vec<ScanResult>,
}

impl k8s_openapi::DeepMerge for Report {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        k8s_openapi::merge_strategies::list::set(&mut self.results, other.results);
    }
}

impl Report {
    /// returns a set of all unique vulnerability IDs (CVEs) found in the report
    pub fn vulenerabilties_ids(&self) -> HashSet<String> {
        let mut ids = HashSet::new();
        for result in &self.results {
            for vulnerability in &result.vulnerabilities {
                ids.insert(vulnerability.cve.clone());
            }
        }
        ids
    }

    pub fn critical_severity_vulnerabilitiest_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("CRITICAL", true, always_allowed)
    }

    pub fn critical_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("CRITICAL", false, always_allowed)
    }

    pub fn high_severity_vulnerabilities_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("HIGH", true, always_allowed)
    }

    pub fn high_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("HIGH", false, always_allowed)
    }

    pub fn medium_severity_vulnerabilities_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("MEDIUM", true, always_allowed)
    }

    pub fn medium_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("MEDIUM", false, always_allowed)
    }

    pub fn low_severity_vulnerabilities_with_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("LOW", true, always_allowed)
    }

    pub fn low_severity_vulnerabilities_without_fixes(
        &self,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        self.find_vulnerabilities("LOW", false, always_allowed)
    }

    fn find_vulnerabilities(
        &self,
        severity: &str,
        has_fix: bool,
        always_allowed: &HashSet<String>,
    ) -> Vec<Vulnerability> {
        let mut vuls = Vec::new();
        for result in &self.results {
            for vulnerability in &result.vulnerabilities {
                if always_allowed.contains(&vulnerability.cve) {
                    continue;
                }
                if vulnerability.severity.eq_ignore_ascii_case(severity)
                    && (has_fix == vulnerability.has_fix())
                {
                    vuls.push(vulnerability.clone());
                }
            }
        }
        vuls
    }
}

#[derive(
    Clone,
    Debug,
    PartialEq,
    k8s_openapi_derive::CustomResourceDefinition,
    serde::Deserialize,
    serde::Serialize,
    schemars::JsonSchema,
)]
#[custom_resource_definition(
    group = "storage.sbombastic.rancher.io",
    version = "v1alpha1",
    plural = "vulnerabilityreports",
    generate_schema,
    namespaced,
    has_subresources = "v1",
    impl_deep_merge
)]
#[serde(rename_all = "camelCase")]
pub(crate) struct VulnerabilityReportSpec {
    /// ImageMetadata contains info about the scanned image
    pub image_metadata: ImageMetadata,

    /// Report is the actual vulnerability scan report
    pub report: Report,
}

impl k8s_openapi::DeepMerge for VulnerabilityReportSpec {
    fn merge_from(&mut self, other: Self)
    where
        Self: Sized,
    {
        self.image_metadata.merge_from(other.image_metadata);
        self.report.merge_from(other.report);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::sbombastic::storage::v1alpha1::{scan_result::Class, vulnerability::Cvss};

    #[test]
    fn parse_vulnerability_report() {
        let vulnerability_report_yaml =
            include_bytes!("../../../../test_data/vulnerabilityreport.yaml");

        let report: VulnerabilityReport =
            serde_yaml::from_slice(vulnerability_report_yaml).expect("cannot parse yaml");
        let report_spec = report.spec.expect("spec is missing");

        assert_eq!(
            report_spec.image_metadata.digest,
            "sha256:ab389e320938f3bd42f45437d381fab28742dadcb892816236801e24a0bef804"
        );
        assert_eq!(report_spec.image_metadata.platform, "linux/arm");
        assert_eq!(report_spec.image_metadata.registry, "test-registry");
        assert_eq!(report_spec.image_metadata.registry_uri, "ghcr.io");
        assert_eq!(
            report_spec.image_metadata.repository,
            "rancher-sandbox/sbombastic/test-assets/golang"
        );
        assert_eq!(report_spec.image_metadata.tag, "1.12-alpine");

        assert!(!report_spec.report.results.is_empty());

        let scan_result = report_spec.report.results.first().unwrap();
        assert_eq!(scan_result.class, Class::OsPackages);
        assert_eq!(scan_result.result_type, "alpine");

        // Check a vulnerability
        let mut cvvs_expected = std::collections::BTreeMap::new();
        cvvs_expected.insert(
            "nvd".to_string(),
            Cvss {
                v3_vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H".to_string(),
                v3_score: "9.1".to_string(),
            },
        );
        cvvs_expected.insert(
            "redhat".to_string(),
            Cvss {
                v3_vector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H".to_string(),
                v3_score: "9.1".to_string(),
            },
        );

        let expected_vul = Vulnerability{
            cve: "CVE-2021-36159".to_string(),
            title: Some("libfetch: an out of boundary read while libfetch uses strtol to parse the relevant numbers into address bytes leads to information leak or crash".to_string()),
            package_name: Some("apk-tools".to_string()),
            package_path: None,
            purl: "pkg:apk/alpine/apk-tools@2.10.4-r3?arch=armv7&distro=3.11.3".to_string(),
            installed_version: "2.10.4-r3".to_string(),
            fixed_versions: Some(vec!["2.10.7-r0".to_string()]),
            diff_id: "sha256:2f1fbf8a09329e4903e8c8ea1e429cce666ad39f92e2ed39ca02bf5f7db89026".to_string(),
            description: Some("libfetch before 2021-07-26, as used in apk-tools, xbps, and other products, mishandles numeric strings for the FTP and HTTP protocols. The FTP passive mode implementation allows an out-of-bounds read because strtol is used to parse the relevant numbers into address bytes. It does not check if the line ends prematurely. If it does, the for-loop condition checks for the '\\0' terminator one byte too late.".to_string()),
            severity: "CRITICAL".to_string(),
            references: Some(
                vec![
                    "https://access.redhat.com/security/cve/CVE-2021-36159".to_string(),
                    "https://github.com/freebsd/freebsd-src/commits/main/lib/libfetch".to_string(),
                    "https://gitlab.alpinelinux.org/alpine/apk-tools/-/issues/10749".to_string(),
                    "https://lists.apache.org/thread.html/r61db8e7dcb56dc000a5387a88f7a473bacec5ee01b9ff3f55308aacc%40%3Cdev.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/r61db8e7dcb56dc000a5387a88f7a473bacec5ee01b9ff3f55308aacc%40%3Cusers.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/rbf4ce74b0d1fa9810dec50ba3ace0caeea677af7c27a97111c06ccb7%40%3Cdev.kafka.apache.org%3E".to_string(),
                    "https://lists.apache.org/thread.html/rbf4ce74b0d1fa9810dec50ba3ace0caeea677af7c27a97111c06ccb7%40%3Cusers.kafka.apache.org%3E".to_string(),
                    "https://nvd.nist.gov/vuln/detail/CVE-2021-36159".to_string(),
                    "https://www.cve.org/CVERecord?id=CVE-2021-36159".to_string(),
                ],
            ),
            cvss: Some(cvvs_expected),
            suppressed: false,
            vex_status: None
        };

        let vuln = scan_result.vulnerabilities.first().unwrap();
        assert_eq!(vuln, &expected_vul);
    }

    #[test]
    fn test_find_vulnerabilies() {
        let critical_no_fix = Vulnerability {
            cve: "critical-no-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "critical-no-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: None,
            diff_id: "sha".to_string(),
            description: None,
            severity: "CRITICAL".to_string(),
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let critical_with_fix = Vulnerability {
            cve: "critical-with-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "critical-with-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: Some(vec!["1.2.3".to_string()]),
            diff_id: "sha".to_string(),
            description: None,
            severity: "CRITICAL".to_string(),
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let medium_no_fix = Vulnerability {
            cve: "medium-no-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "medium-no-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: None,
            diff_id: "sha".to_string(),
            description: None,
            severity: "MEDIUM".to_string(),
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let medium_with_fix = Vulnerability {
            cve: "medium-with-fix".to_string(),
            title: None,
            package_name: None,
            package_path: None,
            purl: "medium-with-fix".to_string(),
            installed_version: "123".to_string(),
            fixed_versions: Some(vec!["1.2.3".to_string()]),
            diff_id: "sha".to_string(),
            description: None,
            severity: "MEDIUM".to_string(),
            references: None,
            cvss: None,
            suppressed: false,
            vex_status: None,
        };

        let report = Report {
            results: vec![ScanResult {
                target: "layer1".to_string(),
                class: Class::OsPackages,
                result_type: "alpine".to_string(),
                vulnerabilities: vec![
                    critical_no_fix.clone(),
                    critical_with_fix.clone(),
                    medium_no_fix,
                    medium_with_fix,
                ],
            }],
        };

        // test find critical with fixes
        assert_eq!(
            report.critical_severity_vulnerabilitiest_with_fixes(&HashSet::new()),
            vec![critical_with_fix.clone()]
        );

        // test find critical without fixes
        assert_eq!(
            report.critical_severity_vulnerabilities_without_fixes(&HashSet::new()),
            vec![critical_no_fix]
        );

        // test find critical with fixes allowing one cve
        assert!(report
            .critical_severity_vulnerabilitiest_with_fixes(
                &vec![critical_with_fix.cve]
                    .into_iter()
                    .collect::<HashSet::<String>>()
            )
            .is_empty());
    }
}
