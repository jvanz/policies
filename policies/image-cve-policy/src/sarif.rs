use std::collections::HashSet;

use crate::errors::ImageValidationError;

pub(crate) mod trivy;

#[derive(PartialEq, Debug, Clone)]
pub(crate) enum Severity {
    Unknown,
    Low,
    Medium,
    High,
    Critical,
}

impl From<&str> for Severity {
    fn from(severity: &str) -> Self {
        match severity {
            "CRITICAL" => Severity::Critical,
            "HIGH" => Severity::High,
            "MEDIUM" => Severity::Medium,
            "LOW" => Severity::Low,
            _ => Severity::Unknown,
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) struct Vulnerability {
    pub id: String,
    pub severity: Severity,
    pub fixed_version: Option<String>,
}

#[derive(Default, Debug)]
pub(crate) struct Report {
    pub vulenerabilties_ids: HashSet<String>,
    pub critical_severity_vulnerabilitiest_with_fix: Vec<Vulnerability>,
    pub critical_severity_vulnerabilities_without_fix: Vec<Vulnerability>,
    pub high_severity_vulnerabilities_with_fix: Vec<Vulnerability>,
    pub high_severity_vulnerabilities_without_fix: Vec<Vulnerability>,
    pub medium_severity_vulnerabilities_with_fix: Vec<Vulnerability>,
    pub medium_severity_vulnerabilities_without_fix: Vec<Vulnerability>,
    pub low_severity_vulnerabilities_with_fix: Vec<Vulnerability>,
    pub low_severity_vulnerabilities_without_fix: Vec<Vulnerability>,
    pub unknown_severity_vulnerabilities: Vec<Vulnerability>,
}

impl Report {
    pub fn new(
        trivy_report: trivy::Report,
        always_allowed: &HashSet<String>,
    ) -> Result<Self, ImageValidationError> {
        if trivy_report.runs.len() != 1 {
            return Err(ImageValidationError::SarifParse(format!(
                "wrong number of 'run' items inside of trivy report, expected 1 got {}",
                trivy_report.runs.len()
            )));
        }

        let vulnerabilities: Vec<Vulnerability> = trivy_report.runs[0]
            .tool
            .driver
            .rules
            .iter()
            .map(|rule| {
                let (severity, fixed_version) = parse_rule_help_text(&rule.help.text);

                Vulnerability {
                    id: rule.id.clone(),
                    severity,
                    fixed_version,
                }
            })
            .collect();

        let mut report = Report {
            ..Default::default()
        };

        for vulnerability in vulnerabilities {
            if always_allowed.contains(&vulnerability.id) {
                continue;
            }

            report.vulenerabilties_ids.insert(vulnerability.id.clone());
            match vulnerability.severity {
                Severity::Critical => {
                    if vulnerability.fixed_version.is_none() {
                        report
                            .critical_severity_vulnerabilities_without_fix
                            .push(vulnerability.to_owned());
                    } else {
                        report
                            .critical_severity_vulnerabilitiest_with_fix
                            .push(vulnerability.to_owned());
                    }
                }
                Severity::High => {
                    if vulnerability.fixed_version.is_none() {
                        report
                            .high_severity_vulnerabilities_without_fix
                            .push(vulnerability.to_owned());
                    } else {
                        report
                            .high_severity_vulnerabilities_with_fix
                            .push(vulnerability.to_owned());
                    }
                }
                Severity::Medium => {
                    if vulnerability.fixed_version.is_none() {
                        report
                            .medium_severity_vulnerabilities_without_fix
                            .push(vulnerability.to_owned());
                    } else {
                        report
                            .medium_severity_vulnerabilities_with_fix
                            .push(vulnerability.to_owned());
                    }
                }
                Severity::Low => {
                    if vulnerability.fixed_version.is_none() {
                        report
                            .low_severity_vulnerabilities_without_fix
                            .push(vulnerability.to_owned());
                    } else {
                        report
                            .low_severity_vulnerabilities_with_fix
                            .push(vulnerability.to_owned());
                    }
                }
                Severity::Unknown => {
                    report
                        .unknown_severity_vulnerabilities
                        .push(vulnerability.to_owned());
                }
            }
        }

        Ok(report)
    }
}

// Parse the help text of a rule to extract information
// Returns a tuple containing the severity and fixed version
fn parse_rule_help_text(help_text: &str) -> (Severity, Option<String>) {
    let mut fixed_version = None;
    let mut severity = Severity::Unknown;

    for line in help_text.lines() {
        let parts: Vec<&str> = line.splitn(2, ':').collect();
        match parts.as_slice() {
            ["Fixed Version", version] => {
                fixed_version = Some(version.trim().to_string()).take_if(|s| !s.is_empty());
            }
            ["Severity", sev] => {
                severity = sev.trim().into();
            }
            _ => {}
        }
    }

    (severity, fixed_version)
}

#[cfg(test)]
mod tests {
    use super::*;

    use rstest::rstest;

    #[rstest]
    #[case::not_fixed(
        "Vulnerability CVE-2011-3374\nSeverity: LOW\nPackage: libapt-pkg6.0\nFixed Version: \nLink: [CVE-2011-3374](https://avd.aquasec.com/nvd/cve-2011-3374)\nIt was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
        Severity::Low,
        None
    )]
    #[case::fixed(
        "Vulnerability CVE-2023-49462\nSeverity: HIGH\nPackage: libheif1\nFixed Version: 1.15.1-1+deb12u1\nLink: [CVE-2023-49462](https://avd.aquasec.com/nvd/cve-2023-49462)\nlibheif v1.17.5 was discovered to contain a segmentation violation via the component /libheif/exif.cc.",
        Severity::High,
        Some("1.15.1-1+deb12u1".to_string())
    )]
    fn extract_information_from_rule_help_text(
        #[case] help_text: &str,
        #[case] expected_severity: Severity,
        #[case] expected_fixed_version: Option<String>,
    ) {
        let (severity, fixed_version) = parse_rule_help_text(help_text);
        assert_eq!(severity, expected_severity);
        assert_eq!(fixed_version, expected_fixed_version);
    }

    #[derive(Clone)]
    pub struct VulnerabilityItem {
        pub cve_id: String,
        pub severity: Severity,
        pub fixed_at: Option<String>,
    }

    pub fn generate_trivy_report(items: &[VulnerabilityItem]) -> serde_json::Value {
        let rules: Vec<serde_json::Value> = items.iter().map(|item| {
            let severity_str = match item.severity {
                Severity::Critical => "CRITICAL",
                Severity::High => "HIGH",
                Severity::Medium => "MEDIUM",
                Severity::Low => "LOW",
                Severity::Unknown => "UNKNOWN",
            };

            serde_json::json!({
                "id": item.cve_id,
                "name": "fixture",
                "help": {
                    "text": format!(
                        "Vulnerability {}\nSeverity: {}\nFixed Version: {}\nLink: [CVE-{}](https://avd.aquasec.com/nvd/{})",
                        item.cve_id,
                        severity_str,
                        item.fixed_at.clone().unwrap_or_default(),
                        item.cve_id,
                        item.cve_id
                    ),
                }
            })
        }).collect();

        serde_json::json!({
            "version": "2.1.0",
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/main/sarif-2.1/schema/sarif-schema-2.1.0.json",
            "runs": [
                {
                    "tool": {
                        "driver": {
                            "fullName": "Trivy Vulnerability Scanner",
                            "informationUri": "https://github.com/aquasecurity/trivy",
                            "name": "Trivy",
                            "rules": rules
                        }
                    }
                }
            ]
        })
    }

    #[derive(Default)]
    struct ExpectedVulnerabilities {
        pub critical_severity_vulnerabilities_without_fix: usize,
        pub critical_severity_vulnerabilitiest_with_fix: usize,
        pub high_severity_vulnerabilities_without_fix: usize,
        pub high_severity_vulnerabilities_with_fix: usize,
        pub medium_severity_vulnerabilities_without_fix: usize,
        pub medium_severity_vulnerabilities_with_fix: usize,
        pub low_severity_vulnerabilities_without_fix: usize,
        pub low_severity_vulnerabilities_with_fix: usize,
        pub unknown_severity_vulnerabilities: usize,
    }

    #[rstest]
    #[case::no_vulnerabilities(Vec::new(), ExpectedVulnerabilities::default())]
    #[case::one_critical_without_fix(vec![
            VulnerabilityItem {
                cve_id: "CVE-2021-4321".to_string(),
                severity: Severity::Critical,
                fixed_at: None,
            },
        ],
        ExpectedVulnerabilities{
            critical_severity_vulnerabilities_without_fix: 1,
            ..Default::default()
        })]
    #[case::one_critical_with_fix(vec![
            VulnerabilityItem {
                cve_id: "CVE-2021-4321".to_string(),
                severity: Severity::Critical,
                fixed_at: Some("1.2.3".to_string()),
            },
        ],
        ExpectedVulnerabilities{
            critical_severity_vulnerabilitiest_with_fix: 1,
            ..Default::default()
        })]
    #[case::mix(vec![
            VulnerabilityItem {
                cve_id: "CVE-2021-4321".to_string(),
                severity: Severity::Critical,
                fixed_at: Some("1.2.3".to_string()),
            },
            VulnerabilityItem {
                cve_id: "CVE-2021-1234".to_string(),
                severity: Severity::High,
                fixed_at: None,
            },
            VulnerabilityItem {
                cve_id: "CVE-2021-5678".to_string(),
                severity: Severity::Medium,
                fixed_at: Some("1.2.3".to_string()),
            },
            VulnerabilityItem {
                cve_id: "CVE-2021-8765".to_string(),
                severity: Severity::Low,
                fixed_at: None,
            },
            VulnerabilityItem {
                cve_id: "CVE-2021-4321".to_string(),
                severity: Severity::Unknown,
                fixed_at: None,
            },
        ],
        ExpectedVulnerabilities{
            critical_severity_vulnerabilitiest_with_fix: 1,
            high_severity_vulnerabilities_without_fix: 1,
            medium_severity_vulnerabilities_with_fix: 1,
            low_severity_vulnerabilities_without_fix: 1,
            unknown_severity_vulnerabilities: 1,
            ..Default::default()
        })]

    fn build_from_trivy_report(
        #[case] vulnerabilities: Vec<VulnerabilityItem>,
        #[case] expected: ExpectedVulnerabilities,
    ) {
        let trivy_report: trivy::Report =
            serde_json::from_value(generate_trivy_report(&vulnerabilities))
                .expect("cannot parse trivy report");

        let expected_vulnerabilities: HashSet<String> = vulnerabilities
            .iter()
            .map(|item| item.cve_id.clone())
            .collect();

        let report = Report::new(trivy_report, &HashSet::new()).expect("cannot build report");
        assert_eq!(
            0,
            report
                .vulenerabilties_ids
                .difference(&expected_vulnerabilities)
                .count()
        );

        assert_eq!(
            report.critical_severity_vulnerabilities_without_fix.len(),
            expected.critical_severity_vulnerabilities_without_fix
        );
        assert_eq!(
            report.critical_severity_vulnerabilitiest_with_fix.len(),
            expected.critical_severity_vulnerabilitiest_with_fix
        );
        assert_eq!(
            report.high_severity_vulnerabilities_without_fix.len(),
            expected.high_severity_vulnerabilities_without_fix
        );
        assert_eq!(
            report.high_severity_vulnerabilities_with_fix.len(),
            expected.high_severity_vulnerabilities_with_fix
        );
        assert_eq!(
            report.medium_severity_vulnerabilities_without_fix.len(),
            expected.medium_severity_vulnerabilities_without_fix
        );
        assert_eq!(
            report.medium_severity_vulnerabilities_with_fix.len(),
            expected.medium_severity_vulnerabilities_with_fix
        );
        assert_eq!(
            report.low_severity_vulnerabilities_without_fix.len(),
            expected.low_severity_vulnerabilities_without_fix
        );
        assert_eq!(
            report.low_severity_vulnerabilities_with_fix.len(),
            expected.low_severity_vulnerabilities_with_fix
        );
        assert_eq!(
            report.unknown_severity_vulnerabilities.len(),
            expected.unknown_severity_vulnerabilities
        );
    }
}
