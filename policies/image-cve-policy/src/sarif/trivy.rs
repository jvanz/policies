use crate::errors::ImageValidationError;
use crate::sbombastic::storage::v1alpha1::vulnerability_report::VulnerabilityReport;

impl TryFrom<VulnerabilityReport> for Report {
    type Error = ImageValidationError;

    fn try_from(sbombastic_vulnerability_report: VulnerabilityReport) -> Result<Self, Self::Error> {
        let spec = sbombastic_vulnerability_report
            .spec
            .ok_or(ImageValidationError::SarifParse(
                "missing VulnerabilityReportSpec".to_string(),
            ))?;

        let report = serde_json::from_value::<Self>(spec.sarif)
            .map_err(|e| ImageValidationError::SarifParse(e.to_string()))?;

        if report.runs.len() != 1 {
            return Err(ImageValidationError::SarifParse(format!(
                "wrong number of 'run' items inside of trivy report, expected 1 got {}",
                report.runs.len()
            )));
        }

        if report.runs[0].tool.driver.name != "Trivy" {
            return Err(ImageValidationError::SarifParse(format!(
                "wrong tool driver name inside of trivy report, expected 'Trivy' got '{}'",
                report.runs[0].tool.driver.name
            )));
        }

        Ok(report)
    }
}

#[derive(Debug, serde::Deserialize)]
pub(crate) struct Report {
    pub runs: Vec<Run>,
}

#[derive(Debug, serde::Deserialize)]
pub(crate) struct Run {
    pub tool: Tool,
}

#[derive(Debug, serde::Deserialize)]
pub(crate) struct Tool {
    pub driver: Driver,
}

#[derive(Debug, serde::Deserialize)]
pub(crate) struct Driver {
    pub name: String,
    pub rules: Vec<Rule>,
}

#[derive(Debug, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Rule {
    pub id: String,
    pub help: Help,
}

#[derive(Debug, serde::Deserialize)]
pub(crate) struct Help {
    pub text: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::sbombastic::storage::v1alpha1::vulnerability_report as sbombastic;

    use rstest::rstest;

    #[rstest]
    #[case::made_by_trivy(include_bytes!("../../test_data/nginx:1.27.1-trivy-from-sbom.sarif"), None)]
    #[case::not_made_by_trivy(include_bytes!("../../test_data/nginx:1.27.1-grype-from-sbom.sarif"), Some("wrong tool driver") )]
    fn parse_vulnerability_report(#[case] raw_json: &[u8], #[case] expected_err_msg: Option<&str>) {
        let vulnerability_report_json: serde_json::Value =
            serde_json::from_slice(raw_json).expect("cannot parse sarif data into JSON");

        let sbombastic_vulnerability_report = sbombastic::VulnerabilityReport {
            spec: Some(sbombastic::VulnerabilityReportSpec {
                image_metadata: sbombastic::ImageMetadata {
                    digest: "sha256:1234567890".to_string(),
                    platform: "linux/amd64".to_string(),
                    registry: "docker.io".to_string(),
                    registry_uri: "docker.io/library/nginx:latest".to_string(),
                    repository: "nginx".to_string(),
                    tag: "latest".to_string(),
                },
                sarif: vulnerability_report_json,
            }),
            ..Default::default()
        };

        let vulnerability_report = Report::try_from(sbombastic_vulnerability_report);
        if let Some(expected_err_msg) = expected_err_msg {
            assert!(vulnerability_report.is_err());
            let err_msg = vulnerability_report.unwrap_err().to_string();
            assert!(
                err_msg.contains(expected_err_msg),
                "found {} instead of {}",
                err_msg,
                expected_err_msg
            );
        } else {
            assert!(vulnerability_report.is_ok());
        }
    }
}
