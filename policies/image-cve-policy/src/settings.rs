use std::collections::HashSet;

use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Eq, Hash, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) enum SeverityCount {
    Total(u32),
    TotalWithoutFixes(u32),
}

#[derive(Serialize, Deserialize, Default, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct MaxSeverity {
    pub critical: Option<SeverityCount>,
    pub high: Option<SeverityCount>,
    pub medium: Option<SeverityCount>,
    pub low: Option<SeverityCount>,
}

impl MaxSeverity {
    pub fn is_configured(&self) -> bool {
        self.critical.is_some()
            || self.high.is_some()
            || self.medium.is_some()
            || self.low.is_some()
    }
}

// Describe the settings your policy expects when
// loaded by the policy server.
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(default, rename_all = "camelCase")]
pub(crate) struct Settings {
    pub max_severity: Option<MaxSeverity>,
    pub allow_always: HashSet<String>,
    pub deny_always: HashSet<String>,
    pub ignore_missing_vulnerability_report: bool,
    pub vulnerability_report_namespace: String,
    pub ignore_vex_status: bool,
}

impl kubewarden_policy_sdk::settings::Validatable for Settings {
    fn validate(&self) -> Result<(), String> {
        if self.vulnerability_report_namespace.is_empty() {
            return Err("vulnerabilityReportNamespace cannot be empty".to_string());
        }

        let allowed_and_denied = self
            .allow_always
            .intersection(&self.deny_always)
            .collect::<Vec<_>>();
        if !allowed_and_denied.is_empty() {
            return Err(format!(
                "The following CVEs are both allowed and denied: {allowed_and_denied:?}"
            ));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::settings::Validatable;
    use serde_json::json;

    #[test]
    fn validate_empty_settings() {
        let settings = Settings::default();

        let validation_result = settings.validate();
        assert!(validation_result.is_err());

        let err_msg = validation_result.unwrap_err();
        assert!(err_msg.contains("vulnerabilityReportNamespace cannot be empty"));

        assert!(settings.validate().is_err());
    }

    #[test]
    fn validate_allowed_and_denied_cves() {
        let settings = Settings {
            allow_always: vec!["CVE-2021-4321".to_string(), "CVE-2021-1234".to_string()]
                .into_iter()
                .collect(),
            deny_always: vec!["CVE-2021-1234".to_string()].into_iter().collect(),
            vulnerability_report_namespace: "default".to_string(),
            ..Default::default()
        };

        let validation_result = settings.validate();
        assert!(validation_result.is_err());
        let err_msg = validation_result.unwrap_err();
        assert!(err_msg.contains("The following CVEs are both allowed and denied"));
        assert!(err_msg.contains("CVE-2021-1234"));
    }

    #[test]
    fn cannot_define_severity_values_with_total_and_total_without_fixes_at_the_same_time() {
        let settings_raw = json!(
            {
                "maxSeverity": {
                    "critical": {
                        "total": 1,
                        "totalWithoutFixes": 2
                    }
                },
                "scanReportNamespace": "default"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(settings
            .unwrap_err()
            .to_string()
            .contains("expected map with a single key"));
    }
}
