use std::collections::HashSet;

use criteria_policy_base::settings::BaseSettings;
use oci_spec::image::Platform as OciPlatform;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Eq, Hash, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) enum SeverityCount {
    Total(u32),
    TotalWithoutFixes(u32),
}

#[derive(Serialize, Deserialize, Default, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct MaxSeverity {
    pub critical: Option<SeverityCount>,
    pub high: Option<SeverityCount>,
    pub medium: Option<SeverityCount>,
    pub low: Option<SeverityCount>,
    pub unknown: Option<SeverityCount>,
}

impl MaxSeverity {
    pub fn is_configured(&self) -> bool {
        self.critical.is_some()
            || self.high.is_some()
            || self.medium.is_some()
            || self.low.is_some()
            || self.unknown.is_some()
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct CvssScore {
    pub threshold: f32,
    pub max_count: u32,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
pub(crate) struct Platform {
    /// This REQUIRED property specifies the CPU architecture.
    /// Must use values listed in the Go Language document for GOARCH (e.g.: amd64, arm64, s390x).
    pub arch: oci_spec::image::Arch,

    /// This REQUIRED property specifies the operating system.
    /// Must use values listed in the Go Language document for GOOS (e.g.: linux, windows, darwin).
    pub os: oci_spec::image::Os,

    /// This OPTIONAL property specifies the version of the operating system targeted by the referenced blob.
    /// Implementations MAY refuse to use manifests where os.version is not known to work with the host OS version.
    /// Valid values are implementation-defined. e.g. 10.0.14393.1066 on windows.
    pub os_version: Option<String>,

    /// This OPTIONAL property specifies an array of strings, each specifying a mandatory OS feature. When os is windows,
    /// should use the following values:
    ///
    /// - win32k: image requires win32k.sys on the host (Note: win32k.sys is missing on Nano Server)
    ///
    /// When os is not windows, values are implementation-defined and SHOULD be submitted to this specification for standardization.
    pub os_features: Option<Vec<String>>,

    /// This OPTIONAL property specifies the variant of the CPU.
    /// Variant values listed in the [Platform Variants](https://github.com/opencontainers/image-spec/blob/main/image-index.md#platform-variants) table.
    pub variant: Option<String>,
}

impl From<&Platform> for OciPlatform {
    fn from(platform: &Platform) -> Self {
        let mut oci_platform = OciPlatform::default();

        oci_platform.set_architecture(platform.arch.clone());
        oci_platform.set_os(platform.os.clone());
        oci_platform.set_os_version(platform.os_version.clone());
        oci_platform.set_os_features(platform.os_features.clone());
        oci_platform.set_variant(platform.variant.clone());

        oci_platform
    }
}

// Describe the settings your policy expects when
// loaded by the policy server.
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(default, rename_all = "camelCase")]
pub(crate) struct Settings {
    pub max_severity: Option<MaxSeverity>,
    pub allow_always: HashSet<String>,
    pub deny_always: HashSet<String>,
    pub ignore_missing_vulnerability_report: bool,
    pub vulnerability_report_namespace: String,
    pub ignore_vex_status: bool,
    pub cvss_score: Option<CvssScore>,

    /// The platform to be checked when a multi architecture image is found.
    /// If not provided, the policy will use the same platform as the node that runs the Policy
    /// Server.
    pub platform: Option<Platform>,

    /// This OPTIONAL property specifies the match criteria for the CVE name.
    pub cve_name: Option<BaseSettings>,
}

impl kubewarden_policy_sdk::settings::Validatable for Settings {
    fn validate(&self) -> Result<(), String> {
        if self.vulnerability_report_namespace.is_empty() {
            return Err("vulnerabilityReportNamespace cannot be empty".to_string());
        }

        let allowed_and_denied = self
            .allow_always
            .intersection(&self.deny_always)
            .collect::<Vec<_>>();
        if !allowed_and_denied.is_empty() {
            return Err(format!(
                "The following CVEs are both allowed and denied: {allowed_and_denied:?}"
            ));
        }

        if let Some(cvss_score) = &self.cvss_score
            && (cvss_score.threshold < 0.0 || cvss_score.threshold > 10.0)
        {
            return Err(format!(
                "cvssScore.threshold must be between 0.0 and 10.0, got {}",
                cvss_score.threshold
            ));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::settings::Validatable;
    use serde_json::json;

    #[test]
    fn validate_empty_settings() {
        let settings = Settings::default();

        let validation_result = settings.validate();
        assert!(validation_result.is_err());

        let err_msg = validation_result.unwrap_err();
        assert!(err_msg.contains("vulnerabilityReportNamespace cannot be empty"));

        assert!(settings.validate().is_err());
    }

    #[test]
    fn validate_allowed_and_denied_cves() {
        let settings = Settings {
            allow_always: vec!["CVE-2021-4321".to_string(), "CVE-2021-1234".to_string()]
                .into_iter()
                .collect(),
            deny_always: vec!["CVE-2021-1234".to_string()].into_iter().collect(),
            vulnerability_report_namespace: "default".to_string(),
            ..Default::default()
        };

        let validation_result = settings.validate();
        assert!(validation_result.is_err());
        let err_msg = validation_result.unwrap_err();
        assert!(err_msg.contains("The following CVEs are both allowed and denied"));
        assert!(err_msg.contains("CVE-2021-1234"));
    }

    #[test]
    fn cannot_define_severity_values_with_total_and_total_without_fixes_at_the_same_time() {
        let settings_raw = json!(
            {
                "maxSeverity": {
                    "critical": {
                        "total": 1,
                        "totalWithoutFixes": 2
                    }
                },
                "scanReportNamespace": "default"
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(
            settings
                .unwrap_err()
                .to_string()
                .contains("expected map with a single key")
        );
    }

    #[test]
    fn validate_cvss_score() {
        let settings_raw = json!(
            {
                "cvssScore": {
                    "threshold": 7,
                }
            }
        );

        let settings = serde_json::from_value::<Settings>(settings_raw);
        assert!(
            settings
                .unwrap_err()
                .to_string()
                .contains("missing field `maxCount`")
        );
    }

    #[test]
    fn validate_cvss_score_threshold_out_of_range() {
        let settings = Settings {
            vulnerability_report_namespace: "default".to_string(),
            cvss_score: Some(CvssScore {
                threshold: 11.0,
                max_count: 0,
            }),
            ..Default::default()
        };

        let validation_result = settings.validate();
        assert!(
            validation_result
                .unwrap_err()
                .to_string()
                .contains("cvssScore.threshold must be between 0.0 and 10.0, got 11")
        );
    }
}
